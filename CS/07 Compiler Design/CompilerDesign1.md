(From unacademy videos)
## Errors
#### Types
- Compiler errors
    - Lexical 
    - Syntax
    - Semantic
- Linker errors
- Preprocessor errors
- Runtime errors
#### During compilation
- Preprocessor errors
- Compiler errors
- Linker errors
- *Note: Logical errors can't be found.*
---
#### Symbol Table
- Data structure modified and accessed in all phases
- Eg: line number, type (semantic phase), offset, address(machine code), etc 
---
### Doubts (Clarifications with terms)
- Parse tree, semantic tree (anotated parse tree)
- Syntax tree

---
## Lexical Analyser
- *Input*: Character stream
- *Output*: Token stream or errors
- Removes all comments and whitespaces 
- Finite automata is used to design
### Other names
- Scanner, Token recogniser, Token generator, Linear Phase, First phase of compiler
### Tokens
- Keyword, Operators, Identifiers, Constants/ Literals, Special symbols (punctuation)
- ***Note: "string_ex", ++, ==, +=, && are single token whereas * * is 2 different tokens*** 
- *Don't count comments*
- Eg: `int 1x;` is invalid as *identifier starts with alphabet or underscore*
### Functions
- Token recogniser and generator, removes comments and whitespace
- Produces lexical errors 
- Largest prefix rule (maximal munch)
---
## Syntax Analysis
- *Input:* Token string
- *Output:* Parse tree and syntax error if any
### Other names
- Syntax verifier, Parse tree generator, second phase
### Syntax error vs Syntactic error
- Sometimes, no lexical errors, can also lead to syntax error. 
- ***; missing - (parse tree can not be generated)*** 
- **Syntactic error**( *Syntax or Semantic error*)
    - `fro(i=0,i<n,i++);` - Semantic error not syntax error
    - fro is valid function call syntax 
    - if fro definition prototype or #include headers are available -- ***No semantic error also*** 
- `if()` or `while()` or `switch()`  error - Missing expression
    - `for(;;)` allows empty expression => *by default true* 
---
### Types of parsers

1. ***Top-Down parsers***
>- Backtracking and non backtracking parsing
- Non backtracking - 1. Recursive descent and 2. Non recursive descent (predictive parse)
1. ***TOP-Down parsers*** 
    1. *LL(0)*
    1. *LL(1)*  *predictive parser*
    1. *Others...*
1. ***Bottom-UP parsers***
    1. *LR* 
        1. LR(0)
        1. SLR(1)
        1. LALR(1)
        1. CLR(1) *also known as LR(1)*
    - ***LR(0) ⊆ SLR(1) ⊆ LALR(1) ⊆ CLR(1)*** 
    1. *Operator Precedence Parser*
1. Others....
- Based on GNF, not practical
---
### Top down parsers Types:
1. Recursive descent 
    - Procedure for every production (NT)
1. Non recursive descent
    - Table implemented (Stored CFG)
---
### LL(1) parser
- can be implemented by both recursive and non recursive
- Usually non recursive (by default) - *table driven parser*
- Predictive parser
    - L = *left to right*
    - L = *Left most derivation*
    - (1) = *one token at a time*
- Steps: 1. Write grammar 2. Build table 3. Implement LL(1) algorithm
### LL(1) grammar
- Unambiguous grammar
- Eliminate Left recursion
    - Possibility of entering infinite loop
    - Left to right recursion conversion
    - **`S -> Sa | b `**
        - **`S -> bS' and S' -> aS' | ^ `**
- Left factoring
#### Follow tips:
##### Note-01:
∈ may appear in the first function of a non-terminal.
∈ will never appear in the follow function of a non-terminal.
##### Note-02:
Before calculating the first and follow functions, eliminate Left Recursion from the grammar, if present.
##### Note-03:
We calculate the follow function of a non-terminal by looking where it is present on the RHS of a production rule.

---
### Top down parsers
- ***Identify if LL(1) grammar*** 
    - Table has atmost one entry
    - No entry in table means SYNTAX ERROR
- Parse table construction
    - Find First for all NT
    - If first has ∈, find follow also
    - Fill in the productions (∈ productions for each follow entry)
- ***Shortcut for identifying LL(1)*** 
    - ***All ambiguous, left recursive, left factored grammar are not LL(1)*** 
    - X -> a1 | a2 
    - *if a1 and a2 not ∈, First(a1) and First(a2) should be disjoint*
    - *if a1 is null, First(a2) and Follow(X) should be disjoint*
    - Check for each production with |, ***single productions like X-> AB is always LL(0)*** 
- ***Set of all languages generated by LL(k) grammar is same as LL(1)***
    - Any LL(k) grammar can be converted to LL(1)
    - LL(0) : S->ab
    - LL(1) : S->a|b
    - LL(2) : S->a|ab
    - LL(4) : S->a|ab|abe|abef
---
### Bottom up parsers
- Shift reduce parser (SR parser)
- Lookahead 
- Parsing algorithm is same for all, only the table is different for SLR, LALR, CLR etc.
- TYPES are LR and OPP
- Powerful and difficult to implement is LR(1) or CLR(1)
    - Easy and simple is LR(0)
<img src="https://user-images.githubusercontent.com/43994542/106783213-09ff5c80-6671-11eb-9537-2b38b904e65e.png" height=200>


